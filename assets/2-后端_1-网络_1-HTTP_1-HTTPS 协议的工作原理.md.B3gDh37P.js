import{_ as a,c as i,o as s,a5 as l}from"./chunks/framework.CAnTzXjG.js";const c=JSON.parse('{"title":"HTTPS 协议的工作原理","description":"","frontmatter":{"date":"2023-11-17T00:00:00.000Z"},"headers":[],"relativePath":"2-后端/1-网络/1-HTTP/1-HTTPS 协议的工作原理.md","filePath":"2-后端/1-网络/1-HTTP/1-HTTPS 协议的工作原理.md"}'),r={name:"2-后端/1-网络/1-HTTP/1-HTTPS 协议的工作原理.md"},t=l('<h1 id="https-协议的工作原理" tabindex="-1">HTTPS 协议的工作原理 <a class="header-anchor" href="#https-协议的工作原理" aria-label="Permalink to &quot;HTTPS 协议的工作原理&quot;">​</a></h1><h2 id="_1-客户端发起-https-请求" tabindex="-1">1. <strong>客户端发起 HTTPS 请求</strong> <a class="header-anchor" href="#_1-客户端发起-https-请求" aria-label="Permalink to &quot;1. **客户端发起 HTTPS 请求**&quot;">​</a></h2><ul><li>当用户在浏览器中输入一个 HTTPS 开头的 URL 并访问网站时，浏览器首先会发起一个 <mark><strong>TLS 握手</strong></mark>，告诉服务器浏览器想要建立一个加密的连接。</li><li>浏览器会向服务器发出请求，包含它所支持的 <mark><strong>TLS 版本</strong>、<strong>加密算法</strong>（如 AES、RSA）、<strong>压缩方法</strong>等信息</mark>。</li></ul><p><strong>示例</strong>：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Client</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Hello:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> TLS</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> version,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> supported</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ciphers,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> compression</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> methods</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><hr><h2 id="_2-服务器响应-传递证书" tabindex="-1">2. <strong>服务器响应，传递证书</strong> <a class="header-anchor" href="#_2-服务器响应-传递证书" aria-label="Permalink to &quot;2. **服务器响应，传递证书**&quot;">​</a></h2><ul><li>服务器接收到浏览器的请求后，会选择一个双方都支持的加密算法（Cipher Suite），并将服务器的 数字证书（包含服务器的公钥）发送给浏览器。这个数字证书通常由<mark>受信任的证书颁发机构（CA</mark>，Certificate Authority）签发。</li></ul><p>服务器传递的内容包括：</p><ul><li><mark><strong>服务器证书</strong></mark>：包含服务器的公钥以及服务器的身份信息。</li><li><strong>服务器支持的<mark>加密算法</mark></strong>。</li></ul><p><strong>示例</strong>：</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Server</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Hello:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Chosen</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cipher,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Server</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Certificate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (includes </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">public</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="_3-浏览器验证服务器证书" tabindex="-1">3. <strong>浏览器验证服务器证书</strong> <a class="header-anchor" href="#_3-浏览器验证服务器证书" aria-label="Permalink to &quot;3. **浏览器验证服务器证书**&quot;">​</a></h2><ul><li>浏览器接收到服务器的证书后，会对证书进行一系列的验证，包括： <ol><li><strong>证书是否由<mark>受信任的 CA 颁发</mark></strong>：浏览器会查看证书的签发者是否在它的受信任 CA 列表中。</li><li><strong>证书是否<mark>有效</mark></strong>：检查证书是否在有效期内。</li><li><strong>证书是否<mark>匹配</mark>当前访问的<mark>域名</mark></strong>：确认证书上的域名与用户访问的域名一致。</li><li><strong>证书是否被吊销</strong>：浏览器通过 OCSP（Online Certificate Status Protocol）或 CRL（Certificate Revocation List）查询证书是否已被吊销。</li></ol></li></ul><p>如果证书通过了所有验证，浏览器就认为服务器是可信的。</p><h2 id="_4-生成会话密钥并加密传输" tabindex="-1">4. <strong>生成会话密钥并加密传输</strong> <a class="header-anchor" href="#_4-生成会话密钥并加密传输" aria-label="Permalink to &quot;4. **生成会话密钥并加密传输**&quot;">​</a></h2><ul><li><strong><mark>浏览器</mark><strong>验证通过后，开始</strong><mark>生成一个会话密钥</mark></strong>（即对称密钥）。会话密钥<strong>用于<mark>加密和解密后续通信中的数据</mark></strong>。</li></ul><p>接下来，浏览器会采取以下步骤：</p><ul><li>浏览器用<mark><strong>服务器的公钥（从服务器证书中获取的）加密这个会话密钥</strong></mark>。</li><li>加密后的会话密钥通过网络<mark><strong>发送给服务器</strong></mark>。</li></ul><p>这个过程确保了即使有人截获了加密的会话密钥，也无法解密，因为只有服务器拥有对应的私钥。</p><p><strong>示例</strong>：</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Client:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [Encrypted </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">session</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> with</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> server&#39;s public key]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><hr><h2 id="_5-服务器解密会话密钥" tabindex="-1">5. <strong>服务器解密会话密钥</strong> <a class="header-anchor" href="#_5-服务器解密会话密钥" aria-label="Permalink to &quot;5. **服务器解密会话密钥**&quot;">​</a></h2><ul><li>服务器接收到加密的会话密钥后，<mark><strong>使用它自己的 私钥 解密</strong></mark>，<mark><strong>得到浏览器生成的会话密钥</strong></mark>。</li></ul><p>至此，双方共享了一个会话密钥，且这个会话密钥是安全的（因为只有服务器拥有对应的私钥）。</p><h2 id="_6-双方使用对称加密进行通信" tabindex="-1">6. <mark><strong>双方使用对称加密进行通信</strong></mark> <a class="header-anchor" href="#_6-双方使用对称加密进行通信" aria-label="Permalink to &quot;6. &lt;mark&gt;**双方使用对称加密进行通信**&lt;/mark&gt;&quot;">​</a></h2><ul><li>现在，客户端和服务器之间已经建立了一个安全的加密通道。</li><li>后续的所有通信（包括用户提交的请求、服务器返回的内容）都使用 <mark><strong>对称加密算法</strong></mark>（如 AES、ChaCha20）加密和解密。</li></ul><p><mark>对称加密</mark>相比于非对称加密（RSA、ECC），计算效率更高，因此<mark>用于实际的数据传输</mark>。而<mark>非对称加密</mark>（RSA）则主要用于<mark>安全的密钥交换</mark>。</p><p>那么浏览器与服务器如何通过这个会话密钥来加密和解密数据呢？</p><h3 id="_6-1-加密请求数据" tabindex="-1">6.1 加密请求数据 <a class="header-anchor" href="#_6-1-加密请求数据" aria-label="Permalink to &quot;6.1 加密请求数据&quot;">​</a></h3><ul><li>当用户在浏览器中发起一个请求时（如登录、提交表单等），浏览器首先将请求内容准备好，包括请求头、请求体（POST 数据或 URL 参数）等。</li><li>然后，浏览器使用 <mark><strong>会话密钥</strong></mark> 对这些数据进行 <mark><strong>加密</strong></mark>。这通常使用一个高效的对称加密算法，比如 AES（高级加密标准）。</li></ul><p>具体的加密步骤如下：</p><ol><li>浏览器获取要发送的数据，如 HTTP 请求的内容（路径、方法、参数等）。</li><li>使用会话密钥和选定的对称加密算法（如 AES）加密数据，生成一个 <mark><strong>密文</strong></mark>（即加密后的数据）。</li><li>浏览器将加密后的数据通过 HTTPS 传输通道发送给服务器。</li></ol><p>加密后的数据即使被拦截，也无法被读取或篡改，除非拥有正确的会话密钥。</p><h3 id="_6-2-服务器解密请求数据" tabindex="-1">6.2 服务器解密请求数据 <a class="header-anchor" href="#_6-2-服务器解密请求数据" aria-label="Permalink to &quot;6.2 服务器解密请求数据&quot;">​</a></h3><ul><li>服务器接收到浏览器加密的请求后，会使用相同的会话密钥进行解密。因为对称加密使用的是相同的密钥，服务器可以用它来还原加密的请求数据。</li></ul><p>具体的解密步骤：</p><ol><li>服务器收到加密的 HTTP 请求数据。</li><li>使用会话密钥和相同的对称解密算法对密文进行解密，得到原始的请求内容。</li><li>服务器根据解密后的请求内容进行相应处理，比如处理用户登录信息、查询数据库等。</li></ol><h3 id="_6-3-加密响应数据" tabindex="-1">6.3 加密响应数据 <a class="header-anchor" href="#_6-3-加密响应数据" aria-label="Permalink to &quot;6.3 加密响应数据&quot;">​</a></h3><p>服务器处理完请求后，需要将响应结果返回给浏览器。响应数据也会经过同样的加密步骤：</p><ol><li>服务器将响应内容（如 HTML 页面、JSON 数据、状态码等）准备好。</li><li>使用会话密钥对响应数据进行加密，生成密文。</li><li>服务器将加密的响应数据通过 HTTPS 传输回给浏览器。</li></ol><h3 id="_6-4-浏览器解密响应数据" tabindex="-1">6.4 浏览器解密响应数据 <a class="header-anchor" href="#_6-4-浏览器解密响应数据" aria-label="Permalink to &quot;6.4 浏览器解密响应数据&quot;">​</a></h3><p>浏览器收到服务器加密的响应后，再次使用会话密钥进行解密，还原成可读的响应内容。然后，浏览器会处理和渲染该内容，比如更新页面、展示用户信息等。</p><h2 id="_7-数据完整性校验" tabindex="-1">7. <strong>数据完整性校验</strong> <a class="header-anchor" href="#_7-数据完整性校验" aria-label="Permalink to &quot;7. **数据完整性校验**&quot;">​</a></h2><ul><li>除了加密，HTTPS 还通过<mark><strong>消息验证码（MAC）或者哈希函数</strong></mark>来保证数据的完整性。</li><li>每次通信时，都会计算发送数据的哈希值，确保数据在传输过程中未被篡改。接收方可以根据传输过来的哈希值检查数据的完整性。</li></ul><h2 id="_8-客户端和服务器的通信" tabindex="-1">8. <strong>客户端和服务器的通信</strong> <a class="header-anchor" href="#_8-客户端和服务器的通信" aria-label="Permalink to &quot;8. **客户端和服务器的通信**&quot;">​</a></h2><ul><li>现在，客户端（浏览器）和服务器之间已经建立了一个安全的通信信道。所有的请求和响应（包括 HTML、CSS、JavaScript 等）都会被加密后再发送，确保数据安全。</li></ul><p>例如：</p><ul><li>用户登录信息、支付信息等敏感数据通过加密通道安全传输。</li><li>即使攻击者拦截了这些数据，也无法解密或篡改。</li></ul><h2 id="_9-连接终止" tabindex="-1">9. <strong>连接终止</strong> <a class="header-anchor" href="#_9-连接终止" aria-label="Permalink to &quot;9. **连接终止**&quot;">​</a></h2><ul><li>当会话结束时（比如关闭浏览器或者超时），客户端和服务器都会通知对方，断开安全连接，释放加密相关的资源（如会话密钥）。</li></ul><h2 id="总结-https-的主要步骤" tabindex="-1">总结 HTTPS 的主要步骤 <a class="header-anchor" href="#总结-https-的主要步骤" aria-label="Permalink to &quot;总结 HTTPS 的主要步骤&quot;">​</a></h2><ol><li><strong>客户端发起 HTTPS 请求</strong>，告知服务器支持的加密算法等信息。</li><li><strong>服务器响应并传递证书</strong>，包括公钥和加密信息。</li><li><strong>浏览器验证服务器证书</strong>，确保服务器可信。</li><li><strong>浏览器生成会话密钥</strong>，并使用服务器的公钥加密会话密钥，发送给服务器。</li><li><strong>服务器使用私钥解密会话密钥</strong>，双方共享会话密钥。</li><li><strong>使用「<strong>会话密钥</strong>」对称加密进行通信</strong>，确保传输中的数据安全和加密。</li><li><strong>数据完整性校验</strong>，保证数据未被篡改。</li><li><strong>双方通信</strong>通过安全通道进行，敏感信息被加密传输。</li><li><strong>连接终止</strong>，释放加密相关资源。</li></ol><h2 id="案例分析" tabindex="-1">案例分析 <a class="header-anchor" href="#案例分析" aria-label="Permalink to &quot;案例分析&quot;">​</a></h2><h3 id="场景-用户登录银行网站" tabindex="-1">场景：用户登录银行网站 <a class="header-anchor" href="#场景-用户登录银行网站" aria-label="Permalink to &quot;场景：用户登录银行网站&quot;">​</a></h3><ol><li>用户输入银行网站的 URL，浏览器通过 HTTPS 发起请求。</li><li>服务器返回包含数字证书的响应，证书中包含银行网站的公钥。</li><li>浏览器验证证书，确保银行网站的身份真实可信。</li><li>浏览器生成一个随机的对称密钥（会话密钥），用银行网站的公钥加密后发送给服务器。</li><li>服务器用私钥解密会话密钥，接下来客户端和服务器就可以通过这个对称密钥加密的安全通道进行通信。</li><li>用户输入登录信息，数据通过对称加密的方式被传输到服务器。</li><li>服务器返回加密后的响应，用户登录成功。</li></ol><p>在这个过程中，用户的登录信息因为被加密，不会被攻击者截获，保证了通信的机密性和安全性。</p>',58),n=[t];function e(o,h,k,p,d,g){return s(),i("div",null,n)}const m=a(r,[["render",e]]);export{c as __pageData,m as default};
